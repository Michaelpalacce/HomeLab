apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: generate-networkpolicy-existing
  annotations:
    policies.kyverno.io/title: Generate NetworkPolicy to Existing Namespaces
    policies.kyverno.io/category: Other
    policies.kyverno.io/severity: medium
    policies.kyverno.io/subject: Namespace, NetworkPolicy
    kyverno.io/kyverno-version: 1.7.0
    policies.kyverno.io/minversion: 1.7.0
    kyverno.io/kubernetes-version: "1.23"
    policies.kyverno.io/description: >-
      A NetworkPolicy is often a critical piece when provisioning new Namespaces,
      but there may be existing Namespaces which also need the same resource. Creating
      each one individually or manipulating each Namespace in order to trigger creation
      is additional overhead. This policy creates a new NetworkPolicy for existing
      Namespaces which results in a default deny behavior and labels it with created-by=kyverno.
      This also generates some additional ns specific networkpolicies.
spec:
  generateExisting: true
  rules:
  - name: generate-paperless-networkpolicy
    match:
      any:
      - resources:
          namespaces:
            - tika
            - gotenberg
            - paperless-ngx
    generate:
      kind: NetworkPolicy
      apiVersion: networking.k8s.io/v1
      name: "{{request.object.metadata.name}}-default-deny"
      namespace: "{{request.object.metadata.name}}"
      synchronize: true
      data:
        metadata:
          labels:
            created-by: kyverno
        spec:
          podSelector: {}
          policyTypes:
          - Egress
          egress: 
          # Allow everywhere but not internally, don't want it communicating to local network
          - to:
            - ipBlock:
                cidr: 0.0.0.0/0
                except:
                - 10.0.0.0/8   # RFC 1918 - Class A private
                - 172.16.0.0/12 # RFC 1918 - Class B private
                - 192.168.0.0/16 # RFC 1918 - Class C private
          # It's ok internally to these namespaces
          - to:
            - namespaceSelector:
                matchLabels:
                  kubernetes.io/metadata.name: "tika"
          - to:
            - namespaceSelector:
                matchLabels:
                  kubernetes.io/metadata.name: "gotenberg"
          - to:
            - namespaceSelector:
                matchLabels:
                  kubernetes.io/metadata.name: "paperless-ngx"
          # DNS is allowed (CoreDNS)
          - to:
            - namespaceSelector:
                matchLabels:
                  kubernetes.io/metadata.name: kube-system
            ports:
            - protocol: UDP
              port: 53
            - protocol: TCP
              port: 53
  - name: generate-existing-networkpolicy
    exclude:
      any:
      - resources:
          namespaces:
            - longhorn-system
            - kyverno
            - kube-system
            - flux-system
            - velero # We want to communicate to all namespaces for backup reasons
            - observeability # Has it's own
            - uptimekuma # A little bit down :)

            # These work together, they have their own policy
            - tika
            - gotenberg
            - paperless-ngx

            # WILL HAVE TO FIX THIS LATER
            - ingress-nginx
            - homepage
            - firefly
    match:
      any:
      - resources:
          kinds:
          - Namespace
    generate:
      kind: NetworkPolicy
      apiVersion: networking.k8s.io/v1
      name: "{{request.object.metadata.name}}-default-deny"
      namespace: "{{request.object.metadata.name}}"
      synchronize: true
      data:
        metadata:
          labels:
            created-by: kyverno
        spec:
          podSelector: {}
          policyTypes:
          - Egress
          egress: 
          # Allow everywhere but not internally, don't want it communicating to local network
          - to:
            - ipBlock:
                cidr: 0.0.0.0/0
                except:
                - 10.0.0.0/8   # RFC 1918 - Class A private
                - 172.16.0.0/12 # RFC 1918 - Class B private
                - 192.168.0.0/16 # RFC 1918 - Class C private
          # It's ok internally to the namespace
          - to:
            - namespaceSelector:
                matchLabels:
                  kubernetes.io/metadata.name: "{{request.object.metadata.name}}"
          # DNS is allowed (CoreDNS)
          - to:
            - namespaceSelector:
                matchLabels:
                  kubernetes.io/metadata.name: kube-system
            ports:
            - protocol: UDP
              port: 53
            - protocol: TCP
              port: 53
              
  - name: generate-uptimekuma-networkpolicy
    match:
      any:
      - resources:
          namespaces:
            - uptimekuma
    generate:
      kind: NetworkPolicy
      apiVersion: networking.k8s.io/v1
      name: "{{request.object.metadata.name}}-default-deny"
      namespace: "{{request.object.metadata.name}}"
      synchronize: true
      data:
        metadata:
          labels:
            created-by: kyverno
        spec:
          podSelector: {}
          policyTypes:
          - Egress
          egress: 
          # Allow everywhere but not internal RFC1918 (except 192.168/16)
          - to:
            - ipBlock:
                cidr: 0.0.0.0/0
                except:
                - 10.0.0.0/8
                - 172.16.0.0/12
          # Allow 192.168.0.0/16 ONLY on 80/443
          - to:
            - ipBlock:
                cidr: 192.168.0.0/16
            ports:
            - protocol: TCP
              port: 80
            - protocol: TCP
              port: 443
          # It's ok internally to the namespace
          - to:
            - namespaceSelector:
                matchLabels:
                  kubernetes.io/metadata.name: "{{request.object.metadata.name}}"
          # DNS is allowed (CoreDNS)
          - to:
            - namespaceSelector:
                matchLabels:
                  kubernetes.io/metadata.name: kube-system
            ports:
            - protocol: UDP
              port: 53
            - protocol: TCP
              port: 53
